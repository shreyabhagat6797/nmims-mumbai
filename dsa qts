'''
Write a python function which accepts two sorted stacks and returns a new stack containing all the elements of input stacks in sorted order.
 
Note: The output stack should be of the size as that of the sum of the sizes of the input stacks.
 
       Sample Input	                                       Expected Output
Stack1 (top - bottom): 7,6,5
Stack2 (top - bottom): 3,2,1	                Stack (top-bottom) : 7,6,5,3,2,1

Stack1 (top - bottom): 15,10,3
Stack2 (top - bottom): 21,9,7	                Stack (top-bottom) : 21,15,10,9,7,3

'''

'''class Stack:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__top=-1

    def get_max_size(self):
        return self.__max_size

    def full(self):
        if(self.__top==self.__max_size-1):
            return True
        return False

    def push(self,data):
        if (self.full()):
            print("overflow")
        else:
            self.__top+=1
            self.__elements[self.__top]=data

    def empty(self):
        if(self.__top==-1):
            return True
        return False

    def pop(self):
        if(self.empty()):
            print("underflow")
        else:
            data=self.__elements[self.__top]
            self.__top-=1
            return data

    def display(self):
        if(self.empty()):
            print("stack is empty")
        else:
            index=self.__top
            while(index>=0):
                print(self.__elements[index])
                index-=1

def merge_stack(stack1,stack2):
    l=[]
    stack3=Stack(stack1.get_max_size()+stack2.get_max_size())
    while(not stack1.empty()):
        l.append(stack1.pop())
    while(not stack2.empty()):
        l.append(stack2.pop())
    l.sort()
    for element in l:
        stack3.push(element)
    return stack3

stack1=Stack(3)
stack1.push(4)
stack1.push(6)
stack1.push(7)

stack2=Stack(4)
stack2.push(40)
stack2.push(43)
stack2.push(53)
stack2.push(60)

print("stack 1: ")
stack1.display()

print("stack 2: ")
stack2.display()

output_stack=merge_stack(stack1,stack2)
print("stack 3:")
output_stack.display()




'''
Given a stack of boxes in different colors. 
Write a python function that accepts the stack of boxes 
and removes those boxes having color other than the primary colors (Red, Green and Blue) from the stack. 
The removed boxes should be en-queued into a new queue and returned. 
The original stack should have only the boxes having primary colors and the order must be maintained.
 
Perform case sensitive string comparison wherever necessary.
 
Note: Consider the queue to be of the same size as that of the original stack

'''

class Stack:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__top=-1

    def get_max_size(self):
        return self.__max_size

    def full(self):
        if(self.__top==self.__max_size-1):
            return True
        return False

    def push(self,data):
        if (self.full()):
            print("overflow")
        else:
            self.__top+=1
            self.__elements[self.__top]=data

    def empty(self):
        if(self.__top==-1):
            return True
        return False

    def pop(self):
        if(self.empty()):
            print("underflow")
        else:
            data=self.__elements[self.__top]
            self.__top-=1
            return data

    def display(self):
        if(self.empty()):
            print("stack is empty")
        else:
            index=self.__top
            while(index>=0):
                print(self.__elements[index])
                index-=1

class Queue:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__rear=-1
        self.__front=0

    def get_max_size(self):
        return self.__max_size

    def full(self):
        if(self.__rear==self.__max_size-1):
            return True
        return False

    def enqueue(self,data):
        if (self.full()):
            print("overflow")
        else:
            self.__rear+=1
            self.__elements[self.__rear]=data

    def empty(self):
        if (self.__front>self.__rear):
            return True
        return False

    def dequeue(self):
        if(self.empty()):
            print("underflow")
        else:
             data=self.__elements[self.__front]
             self.__front+=1
             return data

    def display(self):
        for index in range(self.__front,self.__rear+1):
            print(self.__elements[index])

def separate_boxes(box_stack):
    box_color=['Red','Green','Blue']
    stack=Stack(8)
    queue=Queue(8)
    while(not box_stack.empty()):
        color=box_stack.pop()
        if color in box_color:
            stack.push(color)
        elif color not in box_color:
            queue.enqueue(color)
    while(not stack.empty()):
        box_stack.push(stack.pop())
    return queue

box_stack=Stack(8)
box_stack.push("Red")    
box_stack.push("Magenta")
box_stack.push("Yellow")
box_stack.push("Red")
box_stack.push("Orange")
box_stack.push("Green")
box_stack.push("White")
box_stack.push("Purple")

box_stack.display()
result=separate_boxes(box_stack)
print("boxes in stack: ")
box_stack.display()

print("boxes in queue: ")
result.display()



"""
Write a python program to remove all duplicate elements from a sorted linked list containing integer data.
Use the LinkedList class and methods in it to implement the above program.

Example: 
Input LinkedList: 10 10 20 20 30 30 30 40 50
Output LinkedList: 10 20 30 40 50

"""

class Node:
    def __init__(self,data):
        self.__data=data
        self.__next=None

    def get_data(self):
        return self.__data

    def set_data(self,data):
        self.__data=data

    def get_next(self):
        return self.__next

    def set_next(self,next_node):
        self.__next=next_node


class LinkedList:
    def __init__(self):
        self.__head=None
        self.__tail=None

    def get_head(self):
        return self.__head

    def get_tail(self):
        return self.__tail

    def add(self,data):
        new_node=Node(data)
        if(self.__head is None):
            self.__head=self.__tail=new_node
        else:
            self.__tail.set_next(new_node)
            self.__tail=new_node

    def insert(self,data,data_before):
        new_node=Node(data)
        if(data_before==None):
            new_node.set_next(self.__head)
            self.__head=new_node
            if(new_node.get_next()==None):
                self.__tail=new_node

        else:
            node_before=self.find_node(data_before)
            if(node_before is not None):
                new_node.set_next(node_before.get_next())
                node_before.set_next(new_node)
                if(new_node.get_next() is None):
                    self.__tail=new_node
            else:
                print(data_before,"is not present in the Linked list")

    def display(self):
        temp=self.__head
        while(temp is not None):
            print(temp.get_data())
            temp=temp.get_next()

    def find_node(self,data):
        temp=self.__head
        while(temp is not None):
            if(temp.get_data()==data):
                return temp
            temp=temp.get_next()
        return None

    def delete(self,data):
        node=self.find_node(data)
        if(node is not None):
            if(node==self.__head):
                if(self.__head==self.__tail):
                    self.__tail=None
                self.__head=node.get_next()
            else:
                temp=self.__head
                while(temp is not None):
                    if(temp.get_next()==node):
                        temp.set_next(node.get_next())
                        if(node==self.__tail):
                            self.__tail=temp
                        node.set_next(None)
                        break
                    temp=temp.get_next()
        else:
            print(data,"is not present in Linked list")


def remove_duplicates(duplicate_list):
    temp=duplicate_list.get_head()
    while(temp.get_next()):
        if temp.get_data()==temp.get_next().get_data():
            temp1=temp
            temp=temp.get_next()
            print("Removed: "+str(temp1.get_data()))
            duplicate_list.delete(temp1.get_data())
            continue
        temp=temp.get_next()
    duplicate_list.display()
    return duplicate_list

duplicate_list=LinkedList()
duplicate_list.add(10)
duplicate_list.add(10)
duplicate_list.add(20)
duplicate_list.add(20)
duplicate_list.add(30)
duplicate_list.add(30)
duplicate_list.add(30)
duplicate_list.add(40)
duplicate_list.add(50)

remove_duplicates(duplicate_list)



'''
Given a linked list of characters. Write a python function to return a new string that is created by 
appending all the characters given in the linked list as per the rules given below.

Rules:
1. Replace '*' or '/' by a single space
2. In case of two consecutive occurrences of '*' or '/' , 
replace those two occurrences by a single space and convert the next character to upper case.

Assume that 
1. There will not be more than two consecutive occurrences of '*' or '/'
2. The linked list will always end with an alphabet

Sample Input	                                                                      Expected Output
 
 A,n,*,/,a,p,p,l,e,*,a,/,day,*,*,k,e,e,p,s,/,*,a,/,/,d,o,c,t,o,r,*,A,w,a,y	         An Apple a day Keeps A Doctor Away

'''


class Node:
    def __init__(self,data):
        self.__data=data
        self.__next=None

    def get_data(self):
        return self.__data

    def set_data(self,data):
        self.__data=data

    def get_next(self):
        return self.__next

    def set_next(self,next_node):
        self.__next=next_node

class LinkedList:
    def __init__(self):
        self.__head=None
        self.__tail=None

    def get_head(self):
        return self.__head

    def get_tail(self):
        return self.__tail

    def add(self,data):
        new_node=Node(data)
        if(self.__head is None):
            self.__head=self.__tail=new_node
        else:
            self.__tail.set_next(new_node)
            self.__tail=new_node

    def insert(self,data,data_before):
        new_node=Node(data)
        if(data_before==None):
            new_node.set_next(self.__head)
            self.__head=new_node
            if(new_node.get_next()==None):
                self.__tail=new_node

        else:
            node_before=self.find_node(data_before)
            if(node_before is not None):
                new_node.set_next(node_before.get_next())
                node_before.set_next(new_node)
                if(new_node.get_next() is None):
                    self.__tail=new_node
            else:
                print(data_before,"is not present in the Linked list")

    def display(self):
        temp=self.__head
        while(temp is not None):
            print(temp.get_data())
            temp=temp.get_next()

    def find_node(self,data):
        temp=self.__head
        while(temp is not None):
            if(temp.get_data()==data):
                return temp
            temp=temp.get_next()
        return None

    def delete(self,data):
        node=self.find_node(data)
        if(node is not None):
            if(node==self.__head):
                if(self.__head==self.__tail):
                    self.__tail=None
                self.__head=node.get_next()
            else:
                temp=self.__head
                while(temp is not None):
                    if(temp.get_next()==node):
                        temp.set_next(node.get_next())
                        if(node==self.__tail):
                            self.__tail=temp
                        node.set_next(None)
                        break
                    temp=temp.get_next()
        else:
            print(data,"is not present in Linked list")

def create_new_sentence(word_list):
    new_sentence=""
    count=0
    temp = word_list.get_head()
    status=0
    while(temp):
        ch=temp.get_data()
        if ch=="/" or ch=="*":
            new_sentence+= " "
            if temp.get_next().get_data()=="/" or temp.get_next().get_data()=="*":
                status=1
                temp=temp.get_next()
            temp=temp.get_next()
            continue
        if status == 1:
            ch=ch.upper()
            status=0
        new_sentence+=ch
        temp=temp.get_next()
    return new_sentence

word_list=LinkedList()
word_list.add("T")
word_list.add("h")
word_list.add("e")
word_list.add("/")
word_list.add("*")
word_list.add("s")
word_list.add("k")
word_list.add("y")
word_list.add("*")
word_list.add("i")
word_list.add("s")
word_list.add("/")
word_list.add("/")
word_list.add("b")
word_list.add("l")
word_list.add("u")
word_list.add("e")
result=create_new_sentence(word_list)
print(result)


'''
The Montessari Public School has planned to organize a cultural evening. 
The Teacher has framed a schedule based on an idea given by the students.

Assume that the schedule is as below:

Name	Rahul	    Sheema	Gitu	         Tarun	      Tom
Item	Solo Song	Dance	Plays  Flute	Gymnastics	  MIME

The teacher instructed the children to be ready by holding each other’s hands 
while standing on the stage and they have to come forward and perform when their turn comes. 
It is decided that Rahul would perform at the beginning and once again in the middle of the show. 
After Rahul’s first performance, he would join the other children, in his new position(after Gitu). 
After Rahul occupies the new position, Swetha would join the children at the end for delivering the vote of thanks.
Assume that there will always be odd number of children initially.
Use the Child class and children_list provided to implement the class Performance as given in the below class diagram.
1. In the constructor of Performance class, initialize children_list
2. Display the schedule
3. Change Rahul’s position after his performance and display the updated schedule
4. Add Swetha and display the updated schedule

__init__(children_list)	  Initializes the children list
change_position(child)	  Used to change the position of the child passed as the argument to the middle position
add_new_child(child)	  Used for adding a new child passed as the argument to the end of the schedule


'''

class Node:
    def __init__(self,data):
        self.__data=data
        self.__next=None

    def get_data(self):
        return self.__data

    def set_data(self,data):
        self.__data=data

    def get_next(self):
        return self.__next

    def set_next(self,next_node):
        self.__next=next_node


class LinkedList:
    def __init__(self):
        self.__head=None
        self.__tail=None

    def get_head(self):
        return self.__head

    def get_tail(self):
        return self.__tail

    def add(self,data):
        new_node=Node(data)
        if(self.__head is None):
            self.__head=self.__tail=new_node
        else:
            self.__tail.set_next(new_node)
            self.__tail=new_node

    def insert(self,data,data_before):
        new_node=Node(data)
        if(data_before==None):
            new_node.set_next(self.__head)
            self.__head=new_node
            if(new_node.get_next()==None):
                self.__tail=new_node

        else:
            node_before=self.find_node(data_before)
            if(node_before is not None):
                new_node.set_next(node_before.get_next())
                node_before.set_next(new_node)
                if(new_node.get_next() is None):
                    self.__tail=new_node
            else:
                print(data_before,"is not present in the Linked list")

    def display(self):
        temp=self.__head
        while(temp is not None):
            print(temp.get_data())
            temp=temp.get_next()

    def find_node(self,data):
        temp=self.__head
        while(temp is not None):
            if(temp.get_data()==data):
                return temp
            temp=temp.get_next()
        return None

    def delete(self,data):
        node=self.find_node(data)
        if(node is not None):
            if(node==self.__head):
                if(self.__head==self.__tail):
                    self.__tail=None
                self.__head=node.get_next()
            else:
                temp=self.__head
                while(temp is not None):
                    if(temp.get_next()==node):
                        temp.set_next(node.get_next())
                        if(node==self.__tail):
                            self.__tail=temp
                        node.set_next(None)
                        break
                    temp=temp.get_next()
        else:
            print(data,"is not present in Linked list")

class Child:
    def __init__(self,name,item_to_perform):
        self.__name=name
        self.__item_to_perform=item_to_perform

    def get_name(self):
        return self.__name

    def get_tem_to_perform(self):
        return self.__item_to_perform

    def __str__(self):
        return (self.__name+" "+self.__item_to_perform)

class Performance:
    def __init__(self,children_list):
        self.__children_list=children_list

    def get_children_list(self):
        return self.__children_list

    def change_position(self,child):
        temp=self.__children_list.get_head() 
        temp1=self.__children_list.get_head()
        while(temp.get_next()):
            temp1=temp1.get_next()
            if temp.get_next().get_next():
                temp=temp.get_next().get_next()
        self.__children_list.delete(child)
        self.__children_list.insert(child,temp1.get_data())

    def add_new_child(self,child):
        temp=self.__children_list.get_head()
        while(temp.get_next()):
            temp=temp.get_next()
        self.__children_list.insert(child,temp.get_data())

child1=Child("Rahul","Solo song")
child2=Child("Sheema","Dance")
child3=Child("Gitu","Plays Flute")
child4=Child("Tarun","Gymnastics")
child5=Child("Tom","MIME")

children_list=LinkedList()
children_list.add(child1)
children_list.add(child2)
children_list.add(child3)
children_list.add(child4)
children_list.add(child5)

performance=Performance(children_list)
print("The initial order of list:")
performance.get_children_list().display()
print()
print("After Rahul's performance, the new schedule : ")
performance.change_position(child1)
performance.get_children_list().display()
print()
child6=Child("Swetha","Vote of Thanks")
print("After Swetha is added:")
performance.add_new_child(child6)
performance.get_children_list().display()


'''
Create a class that imitates a select screen. For simplicity, the cursor can only move right!
In the display method, return a string representation of the list, 
but with square brackets around the currently selected element. 
Also, create the method to_the_right, which moves the cursor one element to the right.
The cursor should start at index 0.

Examples

menu = Menu([1, 2, 3])
menu.display() ➞ "[[1], 2, 3]"
menu.to_the_right()
menu.display() ➞ "[1, [2], 3]"

menu.to_the_right()
menu.display() ➞ "[1, 2, [3]]"

menu.to_the_right()
menu.display() ➞ "[[1], 2, 3]"
Notes
The cursor should wrap back round to the start once it reaches the end.

'''

class Menu:
    def __init__(self,list1):
        self.list1=list1
        self.pos=0
        self.len_lst=len(list1)

    def to_the_right(self):
        self.pos=(self.pos+1)%self.len_lst

    def display(self):
        temp_lst=self.list1.copy()
        temp_lst[self.pos]=[temp_lst[self.pos]]
        return str(temp_lst)

menu=Menu([1,2,3])
print(menu.display())

menu.to_the_right()
print(menu.display())

menu.to_the_right()
print(menu.display())

menu.to_the_right()
print(menu.display())

menu.to_the_right()
print(menu.display())



'''
The central library at Mysore has a set of very interesting books and journals. 
The books are arranged in the alphabetical order of their author names. 
So it is very easy for the readers to search for the book.
 
The library has got a set of new books. The librarian wants to arrange them in order too. 
As some books are already arranged in the order, find a suitable way of arranging the new set of books amidst them.
 
Write a python program to arrange all the books in the alphabetical order of the author names.
sort_item_list_by_author(): Accepts the new list of books and returns it sorted in the alphabetical order of their author names.
 
add_new_items(): Accepts the new list of books, sorts it and merges it with the existing books in the library.
Hint - Use sort_item_list_by_author() method for sorting the books.
 
sort_items_by_published_year(): Sorts the list of books (item_list) based on the increasing order of their published years. 
If there are multiple items that are published in the same year, then sort them based on the alphabetical order of their author names.

Note: While sorting the author names in alphabetical order, ignore the special characters including space, if there are any.


'''

class Item:
    def __init__(self,item_name,author_name,published_year):
        self.__item_name=item_name
        self.__author_name=author_name
        self.__published_year=published_year

    def get_item_name(self):
        return self.__item_name

    def get_author_name(self):
        return self.__author_name

    def get_published_year(self):
        return self.__published_year

    def __str__(self):
        return ("{} by {} published in {}".format(self.__item_name,self.__author_name,self.__published_year))

class Library:
    def __init__(self,item_list):
        self.__item_list=item_list

    def get_item_list(self):
        return self.__item_list

    def sort_item_list_by_author(self,new_item_list):
        new_item_list.sort(key=lambda x:' '.join(e for e in x.get_author_name() if e.isalnum()))
        return new_item_list

    def add_new_items(self,new_item_list):
        self.__item_list.extend(new_item_list)
        self.sort_item_list_by_author(self.__item_list)

    def sort_items_by_published_year(self):
        self.sort_item_list_by_author(self.__item_list)
        self.__item_list.sort(key=lambda x:x.get_published_year())

item1=Item("A Mission In Kashmir","Andrew Whitehead",1995)
item2=Item("A Passage of India","E.M.Forster",2012)
item3=Item("A new deal for Asia","Mahathir Mohammad",1999)
item4=Item("A Voice of Freedom","Nayantara Sehgal",2001)
item5=Item("A pair of blue eyes","Thomas Hardy",1998 )

item_list=[item1,item2,item3,item4,item5]

library=Library(item_list)
print("The current items in the library:")
for item in library.get_item_list():
    print(item)

item11=Item("Broken Wing","Sarojini Naidu",2012)
item12=Item("Guide","R.K.Narayanan",2001)
item13=Item("Indian Summers","John Mathews",2001)
item14=Item("Innocent in Death","J.D.Robb",2010)
item15=Item("Life of Pi","Yann Martel",2010 )
item16=Item("Sustainability","Johny",2016)
item17=Item("Look Ahead","E.M.Freddy",2012 )

new_item_list=[item11,item12,item13,item14,item15,item16,item17]

print()
print("the new items to be added: ")
for item in new_item_list:
    print(item)

new_item_list_sorted=library.sort_item_list_by_author(new_item_list)
print()
print("The new items after sorting based on author names:")
for item in new_item_list_sorted:
    print(item.get_author_name())

library.add_new_items(new_item_list_sorted)
print()
print("The final set of items: ")
for item in library.get_item_list():
    print(item)

library.sort_items_by_published_year()
print()
print("The items are sorted based on pulished year:")
for item in library.get_item_list():
    print(item.get_author_name()+" "+str(item.get_published_year()))



'''
Given a list of even length, copy the half with the higher sum of numbers to the other half of the list. 
If the sum of the first half equals the sum of the second half, return the original list.
Examples
balanced([1, 2, 4, 6, 3, 1]) ➞ [6, 3, 1, 6, 3, 1]
# 1 + 2 + 4 < 6 + 3 + 1 sol = [6, 3, 1, 6, 3, 1]
balanced([88, 3, 27, 5, 9, 0, 13, 10]) ➞ [88, 3, 27, 5, 88, 3, 27, 5]
# 88 + 3 + 27 + 5 > 9 + 0 + 13 + 10  sol = [88, 3 ,27 ,5 ,88 ,3 ,27 ,5]
balanced([7, 5, 2, 6, 1, 0, 1, 5, 2, 7, 0, 6]) ➞ [7, 5, 2, 6, 1, 0, 1, 5, 2, 7, 0, 6]
# 7 + 5 + 2 + 6 + 1 + 0 = 1 + 5 + 2 + 7 + 0 + 6 sol =  [7, 5, 2, 6, 1, 0, 1, 5, 2, 7, 0, 6]
Notes
The length of the list is even.

'''

def balanced(lst):
    list1=sum(lst[:len(lst)//2])
    list2=sum(lst[len(lst)//2:])

    if list1==list2:
        return lst
    elif list1>list2:
        print(lst[:len(lst)//2]*2)
    else:
        print(lst[len(lst)//2:]*2)

lst=[1, 2, 4, 6, 3, 1]
balanced(lst)



'''
Alice, a school teacher, has decided to take her 20 students to an exhibition. She got the tickets a week before (T1 to T20) and 
she was informed that students will be allowed only in groups of 10 inside the exhibition hall.
On the day of exhibition, few students did not turn up. 
So the teacher followed the below strategy to identify the first 10 students who were sent as group-1. 

Suppose the ticket id of the students who turned up on that day is as follows:
T20, T5, T10, T1, T2, T8, T16, T17, T9, T4, T12, T13, T18
She made the students stand in a line in increasing order of their ticket numbers. 
They were asked to leave a vacant position, in case a student has not turned up.   
Ex: T1, T2, V, T4, T5, V, V, T8, T9, T10, V, T12, T13, V, V, T16, T17, T18, V, T20 where V - indicates vacant position.

Grouped them into 2 groups of 10 each including vacant positions.
Ex: Group – 1 (T1, T2, V, T4, T5, V, V, T8, T9, T10), Group – 2 (V, T12, T13, V, V, T16, T17, T18, V, T20)
Filled the vacant positions with the students from the next group as shown in the example below.
Ex: Group – 1 (T1, T2, T12, T4, T5, T13, T16, T8, T9, T10) Group -2 (T17, T18, T20)
Write a python function which accepts the unsorted ticket id list and 
returns the list of ticket ids of the ten students who were finally sent inside as part of Group-1.
 
Sample Input	                                                    Expected Output
['T20','T5','T10','T1','T2','T8','T16','T17',
'T9','T4','T12','T13', 'T18']	                        ['T1', 'T2', 'T12', 'T4', 'T5', 'T13', 'T16', 'T8', 'T9', 'T10']

'''

def arrange_tickets(ticket_list):
    new_list=[]
    for i in range(1,21): 
        if "T"+str(i) in ticket_list:
            new_list.append("T"+str(i))
        else:
            if i<=10:
                new_list.append("V")
    print(new_list)
    counter=10
    for index,ticket in enumerate(new_list):
        if ticket=="V" and index<=10:
            new_list[index]=new_list[counter]
            counter+=1
    return new_list[:10]

ticket_list=['T20','T5','T10','T1','T2','T8','T16','T17','T9','T4','T12','T13', 'T18']	

print("ticket ids of all the present students:")
print(ticket_list)

group1=arrange_tickets(ticket_list)
print()
print("group 1 ids:")
print(group1)


'''
Given a list of numbers sorted in ascending order. Write a python function which searches for a given number in the list. 
The given number may occur more than once in the list. 
The function should return the index position at which the last occurrence of the given element is found. 
If the number is not found, return -1.
'''

def last_instance(num_list,key):
    count=0
    index=0
    if key in num_list:
        index=num_list.index(key)
    if index:
        count=num_list.count(key)
    return index+count-1

num_list=[1,1,2,2,3,4,5,5,5,5]
key=7
result=last_instance(num_list,key)

if(result!=-1):
    print("the index is ",result)
else:
    print("number not found")





'''
Mary is a kindergarten teacher. She has given a task to the children after teaching them a list of words. 
The task is to find the unknown words (other than the words they already know) from the given text. 
Write a python function which accepts the text and the known list of words and returns the set of unknown words found.

Return -1 if there are no unknown words.

Sample Input                                            Expected Output

Text: "the sun rises in the east"
Vocabulary: ["sun","in","east","doctor","day"]          {'rises', 'the'}
'''

def find_unknown(text,vocabulary):
    l=[]
    status=0
    text_list=text.split(" ")
    for each_text in text_list:
        if each_text not in vocabulary:
            if "." in each_text:
                each_text=each_text.replace("."," ")
            l.append(each_text)
            status=1
    if status:
        return set(l)
    else:
        return -1

text= "the sun rises in the east"
vocabulary= ["sun","in","east","doctor","day"]  
unknown=find_unknown(text,vocabulary)
print(unknown)


'''
Given an integer between 0 and 26, make a variable (self.answer). 
That variable would be assigned to a string in this format:
"nines:your answer, threes:your answer, ones:your answer"
You need to find out how many ones, threes, and nines 
it would at least take for the number of each to add up to the given integer when multiplied by one, three or nine (depends).

Examples
ones_threes_nines(10) ➞ "nines:1, threes:0, ones:1"

ones_threes_nines(15) ➞ "nines:1, threes:2, ones:0"

ones_threes_nines(22) ➞ "nines:2, threes:1, ones:1"
Notes
•	Each of the ones, threes or nines could only be either 0, 1 or 2.
•	You must use a class.
•	After the comma, you must put a space.

'''

class Ones_three_nine:
    def __init__(self,n):
        self.answer='nines:{} threes:{} ones:{}'.format(n//9,(n%9)//3,n%3)

o=Ones_three_nine(10)
print(o.answer)

'''
Given the participants' score sheet for your University Sports Day, 
you are required to find the runner-up score. You are given scores. 
Store them in a list and find the score of the runner-up.

Sample Input 
5
2 3 6 6 5

Sample Output 
5

'''

n=int(input())
scores=map(int,input().split())
print(sorted(list(set(scores)))[-2])


'''
"WonderLand" water theme park wants to generate tickets for its customers.
Complete the implementation of the requirement based on the given class diagram and code.
       
Class Description:
Theme Park class: Complete the class based on comments given in starter code
Ticket class: Complete the class based on comments given in starter code
Customer class:

Initialize points_earned, food_coupon and ticket to 0, "No" and a Ticket object respectively in the constructor

play_game():
Calculate total points based on the list of games played by the customer
Update attribute, points_earned with the calculated value
ThemePark allows a free ride on Game 2 if the customer has opted for Game 3. 
If this is satisfied, add "Game2" to list_of_games and include its points to total points

update_food_coupon(): They provide food coupon to a customer who has opted Game 4 and has earned more than 15 points.
Update attribute, food_coupon status to "Yes" if the above rule is satisfied

book_ticket():
Calculate ticket amount
If amount can be calculated, generate ticket id, play game, update food coupon and return true
Else, return false
Note: Perform case sensitive string comparison
'''


class ThemePark:
    #dict_of_games contains the game name as key, price/ride and points that can be earned by customer in a list as value
    dict_of_games={"Game1":[35.5,5], "Game2":[40.0,6],"Game3":[120.0,10], "Game4":[60.0,7],"Game5":[25.0,4]}

    @staticmethod
    def validate_game(game_input):
        if game_input.title() in ThemePark.dict_of_games.keys():
            return True
        else:
            False
    
    @staticmethod
    def get_points(game_input):
        for game,points in ThemePark.dict_of_games.items():
            if game_input.title()==game:
                return points[1]
    @staticmethod
    def get_amount(game_input):
        for game,points in ThemePark.dict_of_games.items():
            if game_input.title()==game:
                return points[0]

class Ticket:
    __ticket_count=200
    def __init__(self):
        self.__ticket_id=None
        self.__ticket_amount=0

    def generate_ticket_id(self):
        self.__ticket_id=Ticket.__ticket_count+1
        Ticket.__ticket_count+=1

    def calculate_amount(self, list_of_games):
        for game in list_of_games:
            if ThemePark.validate_game(game):
                self.__ticket_amount+=ThemePark.get_amount(game)
            else:
                self.__ticket_amount=0
                return False
        return True

    def get_ticket_id(self):
        return self.__ticket_id

    def get_ticket_amount(self):
        return self.__ticket_amount

class Customer:
    def __init__(self,name,list_of_games):
        self.__name=name
        self.__list_of_games=list_of_games
        self.__ticket=Ticket()
        self.__points_earned=0
        self.__food_coupon="No"
               
    def play_game(self):
        for game in self.__list_of_games:
            self.__points_earned+=ThemePark.get_points(game)
            if game=="Game3":
                self.__list_of_games.append("Game2")
                
    def update_food_coupon(self):
        if "Game4" in self.__list_of_games and self.__points_earned>15:
            self.__food_coupon="Yes"

    def book_ticket(self):
        if Ticket.calculate_amount(self.__ticket,self.__list_of_games):
            Ticket.generate_ticket_id(self.__ticket)
            self.play_game()
            self.update_food_coupon()
            return True
        else:
            return False

    def get_name(self):
        return self.__name

    def get_list_of_games(self):
        return self.__list_of_games

    def get_ticket(self):
        return self.__ticket

    def get_food_coupon(self):
        return self.__food_coupon

    def get_points_earned(self):
        return self.__points_earned

t=Ticket()
c=Customer("ABC",["Game4","Game3","Game2"])

print(t.calculate_amount(["Game4","Game3","Game2"]))
print(t.get_ticket_amount())

t.generate_ticket_id()
print(t.get_ticket_id())

c.play_game()
c.update_food_coupon()
print(c.get_points_earned())
print(c.get_food_coupon())
print(c.book_ticket())


'''
Create a function that takes two parameters and, if both parameters are strings, add them as
	 if they were integers or if the two parameters are integers, concatenate them.
	
	Examples
	stupid_addition(1, 2) ➞ "12"
	
	stupid_addition("1", "2") ➞ 3
	
	stupid_addition("1", 2) ➞ None
	Notes
	If the two parameters are different data types, return None.
	All parameters will either be strings or integers.

'''

def myFunc(a, b):
    if(type(a) is int and type(b) is int): 
        return str(a)+str(b)
    elif(type(a) is str and type(b) is str):
        return int(a) + int(b)
    return "None"
    
print(myFunc('1', 2))



'''
A train is identified by its name and list of compartments.
The compartments are identified by its name,total seating capacity and the number of passengers.

Write a python program to implement the following:
1. count_compartments()- returns the total number of compartments in the train
2. check_vacancy()- returns the count of the compartments in which more than 50% of the seats are vacant
Note : Compartment list is maintained as a linked list where data in each node refers to a compartment.

'''

class Node:
    def __init__(self,data):
        self.__data=data
        self.__next=None

    def get_data(self):
        return self.__data

    def set_data(self,data):
        self.__data=data

    def get_next(self):
        return self.__next

    def set_next(self,next_node):
        self.__next=next_node

class LinkedList:
    def __init__(self):
        self.__head=None
        self.__tail=None

    def get_head(self):
        return self.__head

    def get_tail(self):
        return self.__tail

    def add(self,data):
        new_node=Node(data)
        if(self.__head is None):
            self.__head=self.__tail=new_node
        else:
            self.__tail.set_next(new_node)
            self.__tail=new_node

    def insert(self,data,data_before):
        new_node=Node(data)
        if(data_before==None):
            new_node.set_next(self.__head)
            self.__head=new_node
            if(new_node.get_next()==None):
                self.__tail=new_node

        else:
            node_before=self.find_node(data_before)
            if(node_before is not None):
                new_node.set_next(node_before.get_next())
                node_before.set_next(new_node)
                if(new_node.get_next() is None):
                    self.__tail=new_node
            else:
                print(data_before,"is not present in the Linked list")

    def display(self):
        temp=self.__head
        while(temp is not None):
            print(temp.get_data())
            temp=temp.get_next()

    def find_node(self,data):
        temp=self.__head
        while(temp is not None):
            if(temp.get_data()==data):
                return temp
            temp=temp.get_next()
        return None

    def delete(self,data):
        node=self.find_node(data)
        if(node is not None):
            if(node==self.__head):
                if(self.__head==self.__tail):
                    self.__tail=None
                self.__head=node.get_next()
            else:
                temp=self.__head
                while(temp is not None):
                    if(temp.get_next()==node):
                        temp.set_next(node.get_next())
                        if(node==self.__tail):
                            self.__tail=temp
                        node.set_next(None)
                        break
                    temp=temp.get_next()
        else:
            print(data,"is not present in Linked list")

class Compartment:
    def __init__(self,compartment_name,no_of_passengers,total_seats):
        self.__compartment_name=compartment_name
        self.__no_of_passengers=no_of_passengers
        self.__total_seats=total_seats

    def get_compartment_name(self):
        return self.__compartment_name

    def get_no_of_passengers(self):
        return self.__no_of_passengers

    def get_total_seats(self):
        return self.__total_seats

class Train:
    def __init__(self,train_name,compartment_list):
        self.__train_name=train_name
        self.__compartment_list=compartment_list

    def get_train_name(self):
        return self.__train_name

    def get_compartment_list(self):
        return self.__compartment_list

    def count_compartment(self):
        temp=self.__compartment_list.get_head()
        count=0
        while(temp):
            count+=1
            temp=temp.get_next()
        return count

    def check_vacancy(self):
        count=0
        temp=self.__compartment_list.get_head()
        while(temp):
            seats=((temp.get_data().get_total_seats())-(temp.get_data().get_no_of_passengers()))/temp.get_data().get_total_seats()
            if seats>0.5:
                count+=1
            temp=temp.get_next()
        return count

compartment1=Compartment("SL",250,400)
compartment2=Compartment("2AC",125,280)
compartment3=Compartment("3AC",120,300)
compartment4=Compartment("FC",160,300)
compartment5=Compartment("1AC",100,210)

compartment_list=LinkedList()
compartment_list.add(compartment1)
compartment_list.add(compartment2)
compartment_list.add(compartment3)
compartment_list.add(compartment4)
compartment_list.add(compartment5)

train1=Train("Shatabdi",compartment_list)
count=train1.count_compartment()
print("total compartments ",count)
print()
vacancy=train1.check_vacancy()
print("more than 50% seats vacant ",vacancy)
    


'''
Mubashir needs to assemble a parcel of ordered chocolates. He got two types of chocolates:
•	Small chocolates (2 grams each)
•	Big chocolates (5 grams each)
Create a function that takes three parameters: Number of small available chocolates n_small, 
number of big chocolates available n_big and desired weight (in grams) of the final parcel order.
The function should return the required number of small chocolates to achieve the goal. 
The function should return -1 if the goal cannot be achieved by any possible combinations of small and big chocolates.

Examples
chocolates_parcel(4, 1, 13) ➞ 4
# 4 small chocolates = 8 grams
# 1 big chocolate = 5 grams
# 8 + 5 = 13 grams
# Required number of small chocolates = 4

chocolates_parcel(4, 1, 14) ➞ -1
# You can not make any combination to reach 14 grams.

chocolates_parcel(2, 1, 7) ➞ 1
# 1 big chocolate = 5 grams
# 1 small chocolates = 2 grams
# 5 + 2 = 7 grams
# Required number of small chocolates = 1
Notes
•	Maximize the use of big chocolates that are available to achieve the desired goal. 
And only then should you proceed to use the small chocolates.
•	You can't break chocolates into small pieces.

'''

def chocolates(small,big,weight):
    result=0
    while weight%5!=0 or big*5<weight:
        weight-=2
        result+=1
    return result if weight>=0 and result<=small else -1

print(chocolates(4,1,13))


'''
The manager of an airport wants to generate various reports.
Details of the flights and passengers are stored as mentioned below:
1. Flight details are stored as a list of strings. Suppose "AI890:BAN:MUM:1400" is a string in the flight details list, 
it should be interpreted as follows: AI890 is the flight name , BAN is the source, MUM is the destination and 1400 is the departure time 
(24 hour format).

2. Passenger details are stored in a dictionary where key is the PNR number of the passenger and 
value is a list containing passenger details. 
Suppose "LW101":["Amanda","AI678","C7",25] is an element in the dictionary, it should be interpreted as follows:
  LW101 is the PNR number of the passenger and  ["Amanda","AI678","C7",25] is the list in which the index 0, 1, 2 and  3  
  represents the passenger name, flight name, seat number and the baggage weight respectively.

Assume that we are considering only those flights which are departing between 0700hrs and 2000hrs.
Write a python program to perform the below mentioned functionalities.

find_flights(flight_time): This method accepts time in 24 hour format and returns the list of flights 
which are waiting to takeoff within another two hours starting from the given time (both inclusive).

sort_flight_list(flight_list): This method takes the flight details list as the input and 
returns the flight details list sorted based on the increasing order of their departure time.

get_passenger_details(flight_detail): This method takes a flight’s detail as input and 
returns the list of PNR numbers of the passengers who are waiting to board the given flight.

security_check(passenger_pnr_list): This method takes the list of PNR numbers of the passengers boarding a specific flight 
as the input and returns the list of PNR numbers of the passengers whose baggage has been cleared.
The baggage will be cleared if the baggage weight is between 0-25kg (both inclusive)

sort_passengers(passenger_pnr_list): This method takes the list of PNR numbers of the passengers whose baggage has been cleared as the input 
and returns the list of PNR numbers sorted based on the increasing order of their seat numbers. ( order of seats: A→J )

boarding(passenger_pnr_list): The passengers who have to board a flight should stand in a queue. 
This method takes the list of PNR numbers of the passengers sorted based on seat numbers as the input and 
returns the queue of PNR numbers of the passengers. The queue should be of the same size as that of the list. 
The first passenger in the list should be the first person to stand in the queue.

seating(passenger_queue):The flight has only one door which is at the back side. 
The passengers who board the flight are expected to occupy seats from the front. 
So the passenger who board last will be able to come out first from the flight. 
This method takes the queue of PNR numbers of the passengers as the input and 
returns the stack ( max size of the stack should be same as the size of the queue) 
which contains the PNR numbers of the passengers representing the seating.

 
'''




import queue


class Queue:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__rear=-1
        self.__front=0

    def is_full(self):
        if(self.__rear==self.__max_size-1):
                return True
        return False

    def is_empty(self):
        if(self.__front>self.__rear):
            return True
        return False

    def enqueue(self,data):
        if(self.is_full()):
            print("Queue is full!!!")
        else:
            self.__rear+=1
            self.__elements[self.__rear]=data

    def dequeue(self):
        if(self.is_empty()):
            print("Queue is empty!!!")
        else:
            data=self.__elements[self.__front]
            self.__front+=1
            return data

    def display(self):
        for index in range(self.__front, self.__rear+1):
            print(self.__elements[index])

    def get_max_size(self):
        return self.__max_size

class Stack:
    def __init__(self,max_size):
        self.__max_size=max_size
        self.__elements=[None]*self.__max_size
        self.__top=-1

    def is_full(self):
        if(self.__top==self.__max_size-1):
            return True
        return False

    def is_empty(self):
        if(self.__top==-1):
            return True
        return False

    def push(self,data):
        if(self.is_full()):
            print("The stack is full!!")
        else:
            self.__top+=1
            self.__elements[self.__top]=data

    def pop(self):
        if(self.is_empty()):
            print("The stack is empty!!")
        else:
            data= self.__elements[self.__top]
            self.__top-=1
            return data

    def display(self):
        if(self.is_empty()):
            print("The stack is empty")
        else:
            index=self.__top
            while(index>=0):
                print(self.__elements[index])
                index-=1

    def get_max_size(self):
        return self.__max_size

flight_details=["AI890:BAN:MUM:1400","AI678:BAN:LON:1200","AI345:BAN:CAN:1410","AF780:BAN:AGF:1340","AI001:BAN:AUS:1500","AI404:BAN:NY:1220"]
 
passenger_details_dict=\
{"LW101":["Amanda","AI678","C7",25],"LW103":["John","AI345","A2",10],"LW107":["Alex","AI678","G5",12],\
"TW700":["Hary","AF780","D2",26],"LW167":["Kate","AI001","G3",25],"LT890":["Wade","AI404","G3",25],\
"TW677":["Preet","AF780","D3",25],"LA106":["Henry","AI001","B5",25.5],"LA104":["Ajay","AI001","A7",23],\
"LW202":["Amy","AI345","C3",24.5],"LT673":["Susan","AI404","J8",5],"TW709":["Tris","AF780","H5",22.5],\
"LA188":["Cameron","AI890","H4",22],"LA902":["Scofield","AI678","G4",23],"TW767":["Pom","AF780","H4",2],\
"LW787":["Burrows","AI890","B4",29],"LW898":["Sara","AI678","E4",14],"LW104":["Williams","AI890","C4",10] }

def find_flights(flight_time):
    l=[]
    for flight in flight_details:
        detail=flight.split(":")
        if int(detail[3]) in range(flight_time,flight_time+201):
            l.append(flight)
    return l

def sortMethod(val):
    val1=val.split(":")
    return int(val1[3])

def sort_flight_list(flight_list):
    flight_list.sort(key=sortMethod)
    return flight_list

def get_passenger_details(flight_detail):
    l=[]
    for key,value in passenger_details_dict.items():
        if value[1] in flight_detail:
            l.append(key)
    return l

def security_check(passenger_pnr_list):
    l=[]
    for pnr in passenger_pnr_list:
        if passenger_details_dict[pnr][3] in range(0,26):
            l.append(pnr)
    return l

def sortPassenger(value):
    detail=passenger_details_dict[value]
    return detail[2]

def sort_passengers(passenger_pnr_list):
    passenger_pnr_list.sort(key=sortPassenger)
    return passenger_pnr_list

def boarding(passenger_pnr_list):
    queue=Queue(len(passenger_pnr_list))
    for pnr in passenger_pnr_list:
        queue.enqueue(pnr)
    return queue

def seating(passenger_queue):
    stack=Stack(passenger_queue.get_max_size())
    while(not passenger_queue.is_empty()):
        stack.push(passenger_queue.dequeue())
    return stack

print("the flight details:")
print(flight_details)
print()

print("the passenger details at the airport:")
print(passenger_details_dict)
print()

time=1130
print("details of the flight between the timings:",time,"and",time+200,"are:")
flight_list=find_flights(time)

flight_list=sort_flight_list(flight_list)
print(flight_list)
print()

print("details of the passengers boarding the flights between the timings",time,"and",(time+200),"are:")
print()
for i in range(0,len(flight_list)):
    flight_data=flight_list[i].split(':')
    flight_name=flight_data[0]
    
    passenger_pnr_list=get_passenger_details(flight_list[i])
    print("PNR details of the passengers boarding the flight",flight_name,":")
    print(passenger_pnr_list)
    
    print()
    updated_passenger_pnr_list=security_check(passenger_pnr_list)
    print("PNR details of the passengers of flight",flight_name," whose baggage has been cleared:")
    print(updated_passenger_pnr_list)
    
    sorted_passenger_pnr_list=sort_passengers(updated_passenger_pnr_list)
    print("PNR details of the passengers of flight",flight_name," sorted based on seating number:")
    print(sorted_passenger_pnr_list)
    
    print()
    print("The PNR details of the passengers at the queue",flight_name,":")
    passenger_queue=boarding(updated_passenger_pnr_list)
    passenger_queue.display()
    
    print()
    seating_stack=seating(passenger_queue)
    print("The PNR details of the passengers in the flight",flight_name,":")
    seating_stack.display()

